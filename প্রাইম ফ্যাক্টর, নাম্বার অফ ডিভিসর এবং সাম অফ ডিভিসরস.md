
## প্রাইম ফ্যাক্টরাইজেশন
প্রাইম ফ্যাক্টরাইজেশন মানে হচ্ছে কোন সংখ্যাকে শুধুমাত্র তার প্রাইম <i>divisors</i> এর গুনফল হিসেবে প্রকাশ করা। যেমনঃ <br>
___
১০ = ২ x ৫<br>
১২ = ২ x ২ x ৩
---
এখন আমরা কত সহজে এই কাজটি কোডের মাধ্যমে করতে পারি? তার আগে তোমাকে অবশ্যই <a href = "#">প্রাইম নাম্বার</a> ও <a href = "#">ডিভিজর</a> সম্পর্কে ক্লিয়ার ধারণা থাকতে হবে। <br>

আমরা জানি কিভাবে $\sqrt{n}$ কমপ্লেক্সিটিতে একটি সংখ্যার <i>divisor</i> বের করা যায়। তাই আমরা $\sqrt{n}$ পর্যন্ত লুপ চালিয়ে দেখবো প্রতিটা divisor কতবার করে সংখ্যাটিতে রয়েছে। যেমনঃ ৪ সংখ্যাটির একটি ডিভিজর হল ২ যা ৪ সংখ্যাটিতে ২ বার রয়েছে। আবার ৩৬০ সংখ্যাটিতে ২ আছে ৩টি, ৩ আছে ২টি এবং ৫ আছে ১টি।<br>

৩৬০ = ২ x ২ x ২ x ৩ x ৩ x ৫ = ২<sup>৩</sup> x ৩<sup>২</sup> x ৫<sup></sup><br>  
---

```c++
vector<long long> Prime_Factorization(long long n) {
    vector<long long> factorization;
    for (long long i = 2; i * i <= n; i++) {
        while (n % i == 0) {
            factorization.push_back(i);
            n /= i;
        }
    }
    if (n > 1)
        factorization.push_back(n);
    return factorization;
}
```
<b>"এখানে i ডিভিজর n সংখ্যাটিতে কতবার রয়েছে তা বের করার অন্য আমরা while লুপ চালিয়ে দিয়েছি এবং প্রতিবারে n কে i দিয়ে ভাগ করে ফেলছি যেন i ডিভিজর হিসেবে n এর মধ্যে আর না থাকে। আমাদের লক্ষ্য হল n এর সকল ডিভিজর সরিয়ে ফেলে n কে ১ বানিয়ে ফেলা।"<br></b>

যেহেতু একটি সংখ্যাকে তার ডিভিজর ছাড়া অন্য কোন সংখ্যাদিয়ে ভাগ করা যায়না, তাই একটি সংখ্যাকে তার ডিভিজরগুলো দিয়ে ভাগ করতে থাকলে একসময় সংখ্যাটিকে ১ বানিয়ে ফেলা সম্ভব। তাহলে কোডের পরের অংশে কেন সংখ্যাটি ১ এর চেয়ে বড় কিনা তা চেক করছি? একটু কাগজে-কলমে চেষ্ঠা করলেই তুমি তা পেয়ে যাবে। এটা খুঁজে বের করার দায়িত্ব তোমার।<br>

এই কোডটির <a href="#">কমপ্লেক্সিটি</a> O($\sqrt{n}$)।  তোমার মনে প্রশ্ন আসতে পারে যে আমি তো অলরেডি $\sqrt{n}$ এর একটি লুপ বাহিরে চালাচ্ছি, আবার ভিতরে আরেকটি while লুপ রয়েছে। তাহলে তো কমপ্লেক্সটি আরও বেশি হয়ার কথা। O($\sqrt{n}$) হল কিভাবে?<br>

আমরা ভিতরের লুপটিতে কি কাজ করছি? সংখ্যাটিকে তার ডিভিজর দিয়ে ভাগ করে ফেলছি। তখন কি আর <b>n</b> এর মান আর আগের জায়গায় রয়েছে? চিন্তা কর, সংখ্যাটি যদি ১৬ হয় তাহলে কি ঘটবে? তুমি প্রথমেই ২ দিয়ে ১৬ কে ৪ বার ভাগ করে ১ বানিয়ে ফেলবে, আর তারপর তোমার $\sqrt{n}$ এর লুপটি আর ঘুরবেনা। আর এই কেসটিই হল আমাদের কোডের বেস্ট কেস। যেখানে টাইম সবচাইতে কম লাগে।<br> এখন প্রশ্ন হল, আমরা একটি সংখ্যাকে কতবার ২ দিয়ে ভাগ করতে পারি?<br> অবশ্যই log<sub>2</sub>n সংখ্যকবার। আর এতবারই আমাদের while লুপটি চলবে। আর তাই এই ক্ষেত্রে কোডের কমপ্লেক্সিটি হবে O(log<sub>2</sub>n).

কিন্তু এবার যদি সংখ্যাটি ১৭ হয়, তাহলে ভিতরের লুপটি কখনই কাজ করবেনা। আর বাহিরের for লুপ $\sqrt{n}$ সংখ্যকবারই চলবে। এই কেসটি হল কোডের worst কেস। আর আমরা সবসময় worst কেস কমপ্লেক্সিটিকেই কোডের কমপ্লেক্সিটি হিসেবে চিন্তা করি। তাই কোডটির কমপ্লেক্সিটি হবে O($\sqrt{n}$)। <br>

আশা করি এ পর্যন্ত তোমরা বুঝতে পেরেছো। কমপ্লেক্সিটি নিয়ে তোমাদের ক্লিয়ার ধারণা না থাকলে তোমরা <a href="#">এই</a> লেখাটি পড়ে আসতে পারো।<br> এখন প্রশ্ন হচ্ছে এর চেয়েও efficient ভাবে কি তুমি প্রাইম ফ্যাক্টর বের করতে পারবে? মনে করো, তোমাকে বলা হল ১ থেকে ১০<sup>৬</sup> পর্যন্ত সকল নাম্বারের প্রাইম ফ্যাক্টর বের করতে। তখন তুমি কি করবে? আমরা এইমাত্র যে কোডটি শিখলাম এভাবে <b>N</b> সংখ্যক নাম্বারের প্রাইম ফ্যাক্টর বের করলে কমপ্লেক্সিটি হবে O($N\sqrt{n}$) যা ১০<sup>৯</sup> এর কাছাকাছি কোন নাম্বার। বুঝতেই পারছো এভাবে তাহলে আমরা এই সমস্যার সমাধান করতে পারবোনা। এর জন্য আমাদের কে এর চেয়ে ভাল কোন সমাধান খুঁজে বের করতে হবে।
