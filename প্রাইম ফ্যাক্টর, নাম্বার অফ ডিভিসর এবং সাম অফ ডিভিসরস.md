
## প্রাইম ফ্যাক্টরাইজেশন
প্রাইম ফ্যাক্টরাইজেশন মানে হচ্ছে কোন সংখ্যাকে শুধুমাত্র তার প্রাইম <i>divisors</i> এর গুনফল হিসেবে প্রকাশ করা। যেমনঃ <br>
___
১০ = ২ x ৫<br>
১২ = ২ x ২ x ৩
---
এখন আমরা কত সহজে এই কাজটি কোডের মাধ্যমে করতে পারি? তার আগে তোমাকে অবশ্যই <a href = "#">প্রাইম নাম্বার</a> ও <a href = "#">ডিভিজর</a> সম্পর্কে ক্লিয়ার ধারণা থাকতে হবে। <br>

আমরা জানি কিভাবে $\sqrt{n}$ কমপ্লেক্সিটিতে একটি সংখ্যার <i>divisor</i> বের করা যায়। তাই আমরা $\sqrt{n}$ পর্যন্ত লুপ চালিয়ে দেখবো প্রতিটা divisor কতবার করে সংখ্যাটিতে রয়েছে। যেমনঃ ৪ সংখ্যাটির একটি ডিভিজর হল ২ যা ৪ সংখ্যাটিতে ২ বার রয়েছে। আবার ৩৬০ সংখ্যাটিতে ২ আছে ৩টি, ৩ আছে ২টি এবং ৫ আছে ১টি।<br>

৩৬০ = ২ x ২ x ২ x ৩ x ৩ x ৫ = ২<sup>৩</sup> x ৩<sup>২</sup> x ৫<sup></sup><br>  
---

```c++
vector<long long> Prime_Factorization(long long n) {
    vector<long long> factorization;
    for (long long i = 2; i * i <= n; i++) {
        while (n % i == 0) {
            factorization.push_back(i);
            n /= i;
        }
    }
    if (n > 1)
        factorization.push_back(n);
    return factorization;
}
```
<b>"এখানে i ডিভিজর n সংখ্যাটিতে কতবার রয়েছে তা বের করার অন্য আমরা while লুপ চালিয়ে দিয়েছি এবং প্রতিবারে n কে i দিয়ে ভাগ করে ফেলছি যেন i ডিভিজর হিসেবে n এর মধ্যে আর না থাকে। আমাদের লক্ষ্য হল n এর সকল ডিভিজর সরিয়ে n কে ১ বানিয়ে ফেলা।"<br></b>

যেহেতু একটি সংখ্যাকে তার ডিভিজর ছাড়া অন্য কোন সংখ্যাদিয়ে ভাগ করা যায়না, তাই একটি সংখ্যাকে তার ডিভিজরগুলো দিয়ে ভাগ করতে থাকলে একসময় সংখ্যাটিকে ১ বানিয়ে ফেলা সম্ভব। তাহলে কোডের পরের অংশে কেন সংখ্যাটি ১ এর চেয়ে বড় কিনা তা চেক করছি? একটু কাগজে-কলমে চেষ্ঠা করলেই তুমি তা পেয়ে যাবে। এটা খুঁজে বের করার দায়িত্ব তোমার।<br>

এই কোডটির <a href="#">কমপ্লেক্সিটি</a> O($\sqrt{n}$)।  তোমার মনে প্রশ্ন আসতে পারে যে আমি তো অলরেডি $\sqrt{n}$ এর একটি লুপ বাহিরে চালাচ্ছি, আবার ভিতরে আরেকটি while লুপ রয়েছে। তাহলে তো কমপ্লেক্সটি আরও বেশি হয়ার কথা। O($\sqrt{n}$) হল কিভাবে?<br>

আমরা ভিতরের লুপটিতে কি কাজ করছি? সংখ্যাটিকে তার ডিভিজর দিয়ে ভাগ করে ফেলছি। তখন কি আর <b>n</b> এর মান আর আগের জায়গায় রয়েছে? চিন্তা কর, সংখ্যাটি যদি ১৬ হয় তাহলে কি ঘটবে? তুমি প্রথমেই ২ দিয়ে ১৬ কে ৪ বার ভাগ করে ১ বানিয়ে ফেলবে, আর তারপর তোমার $\sqrt{n}$ এর লুপটি আর ঘুরবেনা। আর এই কেসটিই হল আমাদের কোডের বেস্ট কেস। যেখানে টাইম সবচাইতে কম লাগে।<br> এখন প্রশ্ন হল, আমরা একটি সংখ্যাকে কতবার ২ দিয়ে ভাগ করতে পারি?<br> অবশ্যই log<sub>2</sub>n সংখ্যকবার। আর এতবারই আমাদের while লুপটি চলবে। আর তাই এই ক্ষেত্রে কোডের কমপ্লেক্সিটি হবে O(log<sub>2</sub>n).

কিন্তু এবার যদি সংখ্যাটি ১৭ হয়, তাহলে ভিতরের লুপটি কখনই কাজ করবেনা। আর বাহিরের for লুপ $\sqrt{n}$ সংখ্যকবারই চলবে। এই কেসটি হল কোডের worst কেস। আর আমরা সবসময় worst কেস কমপ্লেক্সিটিকেই কোডের কমপ্লেক্সিটি হিসেবে চিন্তা করি। তাই কোডটির কমপ্লেক্সিটি হবে O($\sqrt{n}$)। <br>

আশা করি এ পর্যন্ত তোমরা বুঝতে পেরেছো। কমপ্লেক্সিটি নিয়ে তোমাদের ক্লিয়ার ধারণা না থাকলে তোমরা <a href="#">এই</a> লেখাটি পড়ে আসতে পারো।<br> এখন প্রশ্ন হচ্ছে এর চেয়েও efficient ভাবে কি তুমি প্রাইম ফ্যাক্টর বের করতে পারবে? মনে করো, তোমাকে বলা হল ১ থেকে ১০<sup>৬</sup> পর্যন্ত সকল নাম্বারের প্রাইম ফ্যাক্টর বের করতে। তখন তুমি কি করবে? আমরা এইমাত্র যে কোডটি শিখলাম এভাবে <b>N</b> সংখ্যক নাম্বারের প্রাইম ফ্যাক্টর বের করলে কমপ্লেক্সিটি হবে O($N\sqrt{n}$) যা ১০<sup>৯</sup> এর কাছাকাছি কোন নাম্বার। বুঝতেই পারছো এভাবে তাহলে আমরা এই সমস্যার সমাধান করতে পারবোনা। এর জন্য আমাদের কে এর চেয়ে ভাল কোন সমাধান খুঁজে বের করতে হবে।

### Smallest Prime Factor (SPF):
এবার তোমাদেরকে দেখাবো কিভাবে আমরা প্রাইম ফ্যাক্টরের কাজটি $\log(n)$ টাইমে করতে পারি। তার আগে তোমাদেরকে <a href="#">সীভ অফ এরাথোসেন্থেসিস</a> দিয়ে কিভাবে O( Nlog(log(n)) ) টাইমে ১ থেকে N পর্যন্ত সকল প্রাইম নাম্বারকে আলাদা করে ফেলা যায় তা ভালভাবে বুঝতে হবে। <br>
আমরা সীভ এর আইডিয়াটি কাজে লাগিয়ে ১ থেকে ১০<sup>৭</sup> পর্যন্ত সকল নাম্বারের <b><i>Smallest Prime Factor (SPF)</b></i> বা সবচেয়ে ছোট প্রাইম ডিভিজরকে স্টোর করে রাখবো। একাজের মাধ্যমে আমরা কিভাবে লাভবান হচ্ছি?

```c++
void SPF() {
    //শুরুতে সব নাম্বারের ছোট প্রাইম ডিভিজর হিসেবে নিজেদেরকেই এসাইন করা হয়েছে 
    for (int i = 1; i <= 1e7; i++)
        spf[i] = i;
 
    //কাজটি সীভ দিয়ে প্রাইম বের করার মতই
    for (long long i = 2; i * i <= 1e7; i++) {
        if (spf[i] == i) { //চেক করছি সংখ্যাটি প্রাইম কিনা
            for (long long j = i * i; j <= 1e7; j += i)
                if (spf[j] == j) //ছোট প্রাইম ফ্যাক্টরটি অলরেডি এসাইন করা হল কিনা
                    spf[j] = i;
        }
    }
}

vector<long long> Prime_Factorization(long long x) {
    vector<int> factors;
    while (x != 1) { //প্রতি স্টেপে x কে সবচেয়ে ছোট প্রাইম ফ্যাক্টর বা SPF দিয়ে ভাগ করছি
        factors.push_back(spf[x]);
        x = x / spf[x];
    }
    return factors;
}

```
আমরা কিভাবে আমাদের কোডের টাইম কমিয়ে এনেছি তা নিয়ে বিস্তারিত আলোচনা করার জন্য কোডগুলো এখানে আমি দেখিয়ে দিচ্ছি। তোমরা অবশ্যই কোডগুলো মুখস্থ না করে, বুঝে, নিজে নিজে করার চেষ্ঠা করবে।<br>
তোমরা যারা সীভ দিয়ে প্রাইম বের করার প্রক্রিয়াটি ভাল্ভাবে বুঝো তাদের জন্য এই কোডটি অনেকটাই সহজ। আমরা একটু বুদ্ধি খাটিয়ে সীভ এর কাজটি দিয়েই SPF বের করার কাজটি করে ফেলছি। কিভাবে?<br>
SPF ফাংশনটিতে সব নাম্বারের SPF ভ্যালু নিজের ভ্যালু হিসেবেই অ্যাসাইন করা হয়েছে। আমাদের সীভ এর ক্ষেত্রে কোন সংখ্যা প্রাইম কিনা তা যাচাই করার জন্য একটি Mark[] অ্যারে রাখতে হয়। কোন সংখ্যা যদি মার্ক না হয়ে থাকে তাহলে আমরা তাকে পরের লুপটিতে যেতে দেই এবং এই সংখ্যাটি দিয়ে যে সকল নাম্বার প্রাইম নয় তাদেরকে মার্ক করে ফেলি। এখানেও আমরা SPF ফাংশনে সেই একই কাজটি করছি। যেহেতু প্রথমত সবার নিজের ভ্যালু হিসেবে নিজেকেই অ্যাসাইন করা আছে, তাই আমরা দ্বিতীয় লুপে যেতে দেয়ার আগে চেক করে দেখবো এই নাম্বারটি প্রাইম কিনা বা ঐ নাম্বারের ঘরে ভ্যালু হিসেবে এখনও ঐ নাম্বারকেই পাচ্ছি কিনা। এবার দ্বিতীয় লুপে, যে সকল নাম্বারের কাছে আমরা যেতে পারছি এরা কেউই প্রাইম নাম্বার নয় এ ব্যাপারে আমরা নিশ্চিত। যে নাম্বারগুলো প্রাইম নয় তাদের SPF ভ্যালু যদি SPF[] অ্যারেতে সেট না করা হয়ে থাকে কেবল সেই ক্ষেত্রেই আমরা ভ্যালু সেট করবো। কারণ আমরা সকল নাম্বারের সবচাইতে ছোট প্রাইম ফ্যাক্টরকে জমা রাখতে চাইছি। পূর্বে যদি কোন নাম্বার অলরেডি অন্য কোন নাম্বারের SPF ভ্যালু হিসেবে সেট হয়ে যায় তাহলে তার জন্য আর কোন ছোট নাম্বারকে SPF হিসেবে পাওয়ার কোন সুযোগ নেই। কারণ আমরা লুপ চালাচ্ছি ২ থেকে তার বড় সংখ্যাগুলোর দিকে। <br>

<div align="center">
    <img src="https://github.com/Md-Johaer-Plabon/AlgoBangla/blob/main/Contents/sievepic.jpg" height="300" width="450">
</div>
<br>
ছবিটির দিকে দেখো, গোলাপি রঙের ঘরগুলোর SPF ভ্যালু হবে ২। আমরা জানি, প্রথমেই ২ দিয়ে সকল জোড় সংখ্যার ঘরগুলি মার্ক হয়ে যাবে। তাই গোলাপি রঙের ঘরগুলোর সকল সংখ্যাই হচ্ছে জোড় সংখ্যা। এভাবে আকাশি রঙের ঘরগুলোর SPF ভ্যালু হল ৩। ্কারণ এ ঘরগুলোতে সবার আগে আমরা ৩ নিয়েই পৌঁছাতে পারি। এখানে ৬ নাম্বার ঘরটিতে ৩ যেতে পারলেও, যেহেতু ৬ নাম্বার ঘরটি অলরেডি একবার ২ দিয়ে মার্ক হয়ে গিয়েছে তাই আমরা ৩ কে তার ভ্যালু হিসেবে আর সেট করবোনা। কারণ আমরা প্রত্যেকটি নাম্বারের সবচাইতে ছোট প্রাইম ফ্যাক্টরটি স্টোর করছি। ঠিক তেমনই ভাবে ৫ নিয়ে আমরা ১৫ নাম্বার ঘরে যেতে পারলেও, যেহেতু ৩ দিয়ে ১৫ নাম্বার ঘরের ভ্যালু অলরেডি একবার সেট করা হয়ে গিয়েছে, তাই ১৫ এর SPF ভ্যালু হবে ৩। এভাবে ৫ এর জন্য লাল রঙ ও ৭ এর জন্য নীল রঙ দিয়ে ঘরগুলোকে ভরাট করা হয়েছে। তুমি চাইলে খাতা কলমেও এ কাজটি নিজে নিজে করে দেখতে পারো।<br>
আশা করি SPF ভ্যালু বের করার কৌশলটি তোমরা বুঝতে পেরেছো। <br><br>
এবার আমরা <b>Prime_Factorization</b> ফাংশনটিতে "x"  এর প্রাইম ফ্যাক্টরগুলো বের করবো। আমরা প্রতিবারে "x" কে তার SPF ভ্যালু দিয়ে ভাগ করতে থাকবো যতক্ষণ পর্যন্ত "x" এর ভ্যালু ১ না হয়। <br>

<div align="center">
    <img src="https://github.com/Md-Johaer-Plabon/AlgoBangla/blob/main/Contents/Factortree.png" height="450" width="350">
</div>
এই ট্রি এর মাধ্যমে আমরা সহজেই আমাদের ফ্যাক্টর বের করার লুপটিকে সিমুলেট করতে পারি। দেখো, আমরা ৪২০ এর প্রাইম ফ্যাকটরগুলোকে বের করতে চাই। যেহেতু ৪২০ একটি জোড় সংখ্যা, তাই এর SPF ভ্যালু হবে ২। ২ দিয়ে ১ বার ভাগ করার পর আমাদের "x" এর ভ্যালু হবে ২১০ এবং ২১০ এর SPF ভ্যালুও হচ্ছে ২। ২১০ কে ২ দিয়ে ভাগ করে আমরা নতুন "x" পাবো ১০৫। ১০৫ এর SPF ভ্যালু হল ৩। একইভাবে ১০৫ থেকে আমরা পাবো ৩৫, যার SPF ভ্যালু ৫। ৩৫ কে ৫ দিয়ে ভাগ করে আমরা ৭ পাবো। এবং পরিশেষে ৭ কে ৭ দিয়ে ভাগ করে আমরা ১ পেয়ে যাবো! আমাদের ৪২০ এর প্রাইম ফ্যাক্টর বের করা শেষ।

৪২০ = ২<sup>২</sup> x ৩ x ৫ x ৭
---
এই কোডটির টাইম কমপ্লেক্সিটি কিভাবে log(n) হল? আমরা এখন আমাদের কোডের worst কেস খুঁজে বের করবো। ১ থেকে ১০<sup>৭</sup> পর্যন্ত নাম্বারগুলোর মধ্যে যে নাম্বারকে সবচাইতে বেশিবার ২ দিয়ে ভাগ করা যায় সেই নাম্বারটিই আমাদের এই কোডের জন্য worst কেস। কারণ কেবলমাত্র সেই নাম্বারটির জন্যই প্রাইম ফ্যাক্টরের লুপটি সবচাইতে বেশি বার ঘুরবে। নাম্বারটি খুঁজে বের করার দায়িত্ব তোমার।<br>
আমরা আগেই শিখেছি যে, একটি নাম্বারকে ২ দিয়ে ভাগ করা যায় log<sub>2</sub>(n) সংখ্যকবার। তাই কোডটির কমপ্লেক্সিটি O(log<sub>2</sub>(n)) বা O(log(n))।

### Number of Divisors (NOD)
তোমরা যদি ডিভিজর নিয়ে এই লেখাটি পড়ে থাকো, তাহলে নিশ্চয়ই জানো যে, যেকোন সংখ্যার মোট ডিভিজরের সংখ্যা আমরা সহজেই O($\sqrt{n}$) এ বের করে ফেলতে পারি। কিন্তু এখন আমরা দেখবো, কিভাবে SPF ব্যবহার করে আমরা এই কাজটিই O(logn) টাইমে করে ফেলতে পারি। তার জন্য তোমাকে SPF বের করার কাজটি ভালভাবে বুঝতে হবে এবং পাশাপাশি কিছুটা কম্বিনেটরিক্স ও জানতে হবে। <br>

১২ = ২<sup>২</sup> x ৩
---
ভালভাবে খেয়াল করো, ১২ এর সবচাইতে ছোট প্রাইম ফ্যাক্টর হল ২ এবং ২ দিয়ে ১২ কে সর্বোচ্চ ২ বার ভাগ করা যায়। আলোচনার সুবিধার্থে প্রাইম ফ্যাক্টর ৩ কে নিয়ে আমরা পরে ভাববো। <br>
এখন, শুধুমাত্র ২<sup>২</sup> কে নিয়ে আমরা ৩টি ভিন্ন ভিন্ন ডিভিজর পেতে পারি। সেগুলো হচ্ছে {১, ২, ৪}। আবার, শুধুমাত্র ৩ কে প্রাইম ফ্যাক্টর হিসেবে চিন্তা করলে আমরা ভিন্ন ডিভিজর পাবো ২ টি, {১, ৩}। তুমি ভালভাবে খেয়াল করলে বুঝতে পারবে যে, আমরা প্রতিটা প্রাইম ফ্যাক্টরের জন্য টোটাল ডিভিজর পাচ্ছি ঐ প্রাইম ফ্যাক্টরের পাওয়ারের থেকে ১ টি বেশি। 

X = P<sub>1</sub><sup>n<sub>1</sub></sup> x P<sub>2</sub><sup>n<sub>2</sub></sup> x P<sub>3</sub><sup>n<sub>3</sub></sup>
---
অর্থাৎ, শুধুমাত্র P<sub>1</sub> প্রাইম ফ্যাক্টরটির জন্য তুমি ভিন্ন ভিন্ন ডিভিজর পাবে (n<sub>1</sub>+1) টি।  অনুরূপভাবে, শুধুমাত্র P<sub>২</sub> প্রাইম ফ্যাক্টরটির জন্য তুমি ভিন্ন ভিন্ন ডিভিজর পাবে (n<sub>2</sub>+1) টি। আমরা সবসময়ই ১ টি ডিভিজর বেশি পাচ্ছি। কারণ সকল সংখ্যারই একটা কমন ডিভিজর হচ্ছে ১। এখন তোমার মনে প্রশ্ন হতে পারে যে, ১ কে আমরা কেন এতবার ডিভিজর হিসেবে নিচ্ছি? চিন্তা করে দেখ, ১ কে আমরা বারবার নিচ্ছি কারণ আমরা প্রতিটা প্রাইম ফ্যাক্টরের জন্য পৃথক পৃথকভাবে শুধুমাত্র ঐ প্রাইম ফ্যাক্টরের জন্য যে ভিন্ন ভিন্ন ডিভিজরগুলো পাই, তা বের করছি। এবার আমরা যদি বিষয়টাকে সেট এর মত করে চিন্তা করি তাহলে কাজটি আমাদের জন্য খুবই সোজা।<br>
ধরো, n<sub>1</sub> = 2, n<sub>2</sub> = 2, n<sub>3</sub> = 1 এবং P<sub>1</sub><sup>n<sub>1</sub></sup> এর জন্য ডিভিজরের সেট {1, a<sub>1</sub>,  a<sub>3</sub>}, P<sub>2</sub><sup>n<sub>2</sub></sup> = {1, b<sub>1</sub>,  b<sub>2</sub>} ও P<sub>3</sub><sup>n<sub>3</sub></sup> = {1, c<sub>1</sub>}। <br>তাহলে তিনটি ভিন্ন ভিন্ন সেট থেকে আমরা কতগুলো ভিন্ন ভিন্ন ডিভিজর পাবো?

NOD = {1, a<sub>1</sub>,  a<sub>3</sub>} x {1, b<sub>1</sub>,  b<sub>2</sub>} x {1, c<sub>1</sub>}
---
এই সেটগুলোর কার্টেসিয়ান প্রোডাক্ট বের করলে যতগুলো pair পাওয়া যাবে, X এর ঠিক ততগুলোই ডিভিজর রয়েছে। সেট এর মাল্টিপ্লিকেশন প্রিন্সিপল অনুসারে আমরা মোট এলিমেন্ট পাবো (n<sub>1</sub>+1) x (n<sub>2</sub>+1) x (n<sub>3</sub>+1) টি অর্থাৎ (২ + ১) x (২ + ১) x (১ + ১) বা ১৮ টি। এখন তুমি সহজেই ১২ এর ডিভিজর সংখ্যা বের করতে পারবে। ১২ এর ডিভিজর হবে (২ + ১) x (১ +১) বা ৬ টি। <br> বুঝতেই পারছো যে, আমরা যদি SPF দিয়ে প্রাইম ফ্যাক্টরগুলো logn টাইমে বের করে ফেলি, তাহলে logn টাইমে Number of Divisors বা NOD ও বের করে ফেলতে পারবো। <br>

### Sum of Divisors (SOD)
তোমাকে যদি বলা হয়, যেকোন একটি সংখ্যার সকল ডিভিজরের যোগফল বা Sum বের করতে, তাহলে তোমার কোডের কমপ্লেক্সিটি কত হবে? আমরা O($\sqrt{n}$) এ যেকোন সংখ্যার সকল ডিভিজর বের করতে পারি, তাই কাজটি O($\sqrt{n}$) এ করা খুবই সোজা। কিন্তু এখন আমরা শিখবো, কিভাবে SPF দিয়ে O(logn) এ কোন সংখ্যার Sum of Divisors (SOD) বের করা যায়। <br> তবে একটা বিষইয়ে তোমাকে অবশ্যই খেয়াল রাখতে হবে, আমাদের কোন সংখ্যার SPF বের করার জন্য সীভ দরকার হয়। আর আমরা সীভ দিয়ে সর্বোচ্চ ১০<sup>৭</sup> পর্যন্ত SPF ভ্যালু জেনারেট করতে পারি। <b>তাই শুধুমাত্র ১০<sup>৭</sup> পর্যন্ত যেকোন সংখ্যার SOD বা NOD তুমি logn টাইমে বের করতে পারবে।</b><br>
এবার আমরা কিভাবে logn টাইমে SOD এর করা যায় তা শিখবো। <br>
"৯" সংখ্যাটির ক্ষেত্রে চিন্তা কর, ৯ এর প্রাইম ফ্যাক্টরাইজেশন হল $৯ = {৩^২}$। তাহলে ৯ এর ডিভিজরগুলো কি কি?


৯ এর ডিভিজরের সেট, s<sub>1</sub>= {${৩^০, ৩^১, ৩^২}$}<br>
৯ এর SOD = ${৩^০ + ৩^১ + ৩^২}$
---
আবার,<br>
১২ এর ডিভিজরের সেট, s<sub>1</sub> = {${২^০, ২^১, ২^২}$} এবং s<sub>২</sub> = {${৩^০, ৩^১}$}<br>
১২ এর SOD = $({২^০ + ২^১ + ২^২}) \cdot ({৩^০ + ৩^১})$ 
---
অর্থাৎ n = ${p_{1}^{e_{1}}} \cdot {p_{2}^{e_{2}}}$ হলে, 
n এর SOD হবেঃ <br>
$(1 + p_{1} + {p_{1}^{2}} + {p_{1}^{3}} +\cdot\cdot\cdot + {p_{1}^{e_{1}}}) \cdot (1 + p_{2} + {p_{2}^{2}} + {p_{2}^{3}} +\cdot\cdot\cdot + {p_{2}^{e_{2}}})$<br>
আবার,<br>
$(1 + p_{1} + {p_{1}^{2}} + {p_{1}^{3}} +\cdot\cdot\cdot + {p_{1}^{e_{1}}}) = \frac{p_{1}^{e_{1} + 1} - 1}{p_{1} - 1}$<br>
---
তাহলে,<br>
SOD = $\frac{p_{1}^{e_{1} + 1} - 1}{p_{1} - 1} \cdot \frac{p_{2}^{e_{2} + 1} - 1}{p_{2} - 1}$
---
এভাবে আমরা series sum এর সূত্র দিয়ে সহজেই SOD বের করে ফেলতে পারি। তুমি SPF পারলে এই কোডটি লেখা তোমার জন্য খুবই সোজা। আমার কোডটি দেখার আগে অবশ্যই তুমি আগে নিজে চেষ্ঠা করবে, তা নাহলে তোমার ইমপ্লিমেন্টেশন করার সক্ষমতা বাড়বেনা।
```c++
long long Sum_of_Divisors(long long x) {
    long long SOD = 1;
    while (x != 1) { 
        long long factor = spf[x], count = 0;
        while(x % factor == 0){ 
            x = x / factor;
            count++;
        }
        SOD *= (long long)pow(factor, count + 1) - 1; 
        SOD /= (factor - 1);
    }
    return SOD;
}
```
কোডটির কমপ্লেক্সিটি হবে O($\log{n}$)। আশা করি বুঝতে পেরেছো।
