
# মডুলার অ্যারিথমেটিক
Modular Arithmatic (ভাগশেষের পাটিগণিত) নাম্বার থিওরি জগতের অন্যতম গুরুত্বপূর্ণ একটি অধ্যায়। যেকোনো নরমাল রেঞ্জ এর নাম্বার যাদেরকে আমরা কোনো প্রোগ্রামিং ল্যাঙ্গুয়েজ এর বেসিক ডাটা টাইপ (যেমন int, long, long long) এ রেখে পাটিগণিতের বেসিক এরিথমেটিক অপারেশন যেমন যোগ, বিয়োগ, গুন্, ভাগ (ভাগ নিয়ে  আপাতত আলোচনা করছি না) গুলো করতে পারি। কিন্তু এর চেয়ে বড় কোনো সংখ্যা যাদেরকে আমরা সম্পূর্ণরূপে কোনো ডাটা টাইপ এ রাখতে পারি না, তাদেরকে নিয়ে কিভাবে কাজ করা যায়? 

মনে করো তোমাকে খুব বড় দুটি সংখ্যা যেমন ২^৯৯ আর ২^১০০ যোগ করতে  দেয়া হয়েছে। তোমাকে সংখ্যাদুটোর যোগফল পূর্ণসংখ্যাটি দিতে হবে না, শুধুমাত্র শেষের ৬-৭ টি ডিজিট দিলেই চলবে। তাহলে এখন তুমি কিভাবে করবে? প্রশ্নটির উত্তর যদি তুমি এক ঝলকে চিন্তা ছাড়াই বলে ফেলতে না পারো, তাহলে এই লিখাটি তোমার জন্যই, স্বাগতম তোমাকে। আপাতত প্রশ্নটি মাথায় রেখে সামনে যাওয়া যাক।

# ভাগশেষ
কোনো সংখ্যা N কে ম্যাথমেটিক্যালি প্রকাশ করার একটা সুন্দর পদ্ধতি হলো N=D*Q+r, যেখানে D হচ্ছে ভাজক (Divisor), Q হচ্ছে  ভাগফল (Quotient), আর r হচ্ছে ভাগশেষ (reminder)। আচ্ছা, ২৭ কে ৫ দিয়ে ভাগ করলে ভাগশেষ কত? বিড়বিড় করে হয়তো হিসেবে করে ফেলেছো, উত্তর ২। এবার যদি বলি, -২৭ কে ৫ দিয়ে ভাগ করলে ভাগশেষ কত, তাহলে তোমার উত্তর কত? 

এর আগে জানা দরকার আসলে ভাগশেষের কনসেপ্ট আমাদের কতটুকু সুস্পষ্ট।  ভাগশেষ হচ্ছে কোনো পূর্ণসংখ্যাকে অন্য পূর্ণসংখ্যা দিয়ে ভাগ করলে অবশিষ্ট অংশ। ২৭ কে যখন আমরা ৫ দিয়ে ভাগ করি, তখন আমরা মূলত ২৭ এর সমান/ছোট সবচেয়ে বড় ৫ এর গুণিতক খুঁজে বের করি (৫*৫=২৫)। তাহলে ভাগশেষ হবে ২৭-২৫=২। তাহলে যখন আমরা -২৭ কে ৫ দিয়ে ভাগ করবো, তখন তার সমান/ছোট সবচেয়ে বড় ৫ এর গুণিতক কত? -৩০ নাকি -২৫? লজিক্যালি কখনোই -২৫ হবে না, কারণ -২৫ অবশ্যই -২৭ অপেক্ষা বড় । তাহলে ভাগশেষ হবে -২৭-(-৩০) = -২৭+৩০ = ৩। আরেকটা বিষয় হচ্ছে, যদি আমরা -২৫ কে ভুলক্রমে নিয়েও  ফেলি,তাহলে ভাগশেষ হবে -২৭-(-২৫) = -২৭+২৫ = -২। জ্ঞাতার্থে জানিয়ে রাখি, ভাগশেষ, তথা "অবশিষ্ট" কখনোই ঋণাত্মক হতে পারে না।

এইবার তুমি একটা ঝটফট কোড লিখে ফেলতে পারো ভাগশেষ নির্ণয় করার। C /C++ এ যদি লিখার চেষ্টা করো, তাহলে কোড টি হবে নিম্নরূপ:

```cpp
int getReminder(int n, int m) {
    int rem = n % m;
    return rem;
}
```

কিন্তু দুঃখের বিষয় হলো, কোডটি তোমায় চরম হতাশ করে ফেলবে, আমার এতো জ্ঞানগর্ভ আলোচনা বৃথা মনে হবে (ঠিকানা জানলে বাসায় এসে কথা শুনিয়ে যেতেও পারো)। কেননা C/C++ বিল্ট-ইন মডুলো অপারেটর তোমাকে রিটার্ন করবে ২৭ mod ৫ = -২। কিন্তু বাস্তবতা হলো, কম্পাইলার এখানে -২৭ এর জন্য ৫ এর গুণিতক নিয়েছে -২৫, যা আমরা ইতোপূর্বে প্রমান করেছি যে এটি ভুল সিদ্ধান্ত। তাহলে আমরা এখন কিভাবে আমাদের প্রয়োজনীয় আউটপুট পেতে পারি?

কোনো সংখ্যা N কে যদি M দ্বারা ভাগ করে ভাগশেষ r পাওয়া যায়, তাহলে N+M, N+২M, N+৩M, ... সবার জন্যই ভাগশেষ হবে r । উদাহরণস্বরূপ, ২৭ mod ৫ = ২, তাহলে ২৭, ৩২, ৩৭, ৪২, .... সবার জন্যই ভাগশেষ ২। কেননা ৫ ভাজকের জন্য ভাগশেষ প্রতি ৫ সংখ্যা পর পর রিপিট করবে (০, ১, ২, ৩, ৪, ০, ১, ...)।  অনুরূপ ঘটনা ঋণাত্মক দিকেও প্রযোজ্য, (..., ১২, ১৭, ২২, ২৭) এর জন্যও  ভাগশেষ হবে ২।
তাহলে আমরা ঋণাত্মক সংখ্যার ভাগশেষ কিভাবে নির্ণয় করতে পারি? একটা পদ্ধতি হতে পারে যে, ঋণাত্মক সংখ্যাটির সাথে এমন একটা ভাজক ৫ এর ধনাত্মক গুণিতক যোগ করবো, যেন তাদের যোগফল ধনাত্মক হয়, তাহলে ওই নম্বর এর ভাগশেষ হবে প্রদত্ত ঋণাত্মক সংখ্যাটির ভাগশেষ। অর্থাৎ, -২৭ mod ৫ = (-২৭ + ৫*১০)mod ৫ = ২৩ mod ৫ = ৩।

দ্বিতীয় পদ্ধতি টি অনেক সিম্পল, সহজ এবং বোধগম্য। ভাগশেষের সাথে ৫ এর যেকোনো গুণিতক যোগ করে যদি আবার ভাগশেষ বের করি, তাহলে কি আমরা নতুন কোনো ভাগশেষ পাবো? কখনোই সম্ভব না, কারণ সবসময় গুণিতক পরিমান বাড়ছে, আবার ভাগ হয়ে ভাগশেষের সমান হয়ে যাচ্ছে। এই প্রেক্ষিতে বলতে পারি, (N mod M) = ((N mod M) + M) mod M। 
এই ছোট্ট লজিক টা যদি আমরা কনসিডার করি, তাহলে ঋণাত্মক সংহার জন্য  কম্পাইলার এর করা ভুল এড়িয়ে আমরা আমাদের কাঙ্খিত রেজাল্ট পেতে পারবো। 

অর্থাৎ,
 ২৭ mod ৫ = ((২৭ mod ৫) + ৫) mod ৫ = (২ + ৫) mod ৫ = ৭ mod ৫ = ২

 -২৭ mod ৫ = ((-২৭ mod ৫) + ৫) mod ৫ = (-২ + ৫) mod ৫ = ৩ mod ৫ = ৩

তাহলে এখন কোড টি হবে নিম্নরূপ, যা সকল সংখ্যার জন্য কার্যকর:

```cpp
int getReminder(int n, int m) {
    int rem = ((n % m) + m) % m;
    return rem;
}
```
