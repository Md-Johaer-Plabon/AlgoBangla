# সিভ অফ এরাটোস্থেনেস (Seive of Eratosthenes)


আমরা জানি মৌলিক সংখ্যা হচ্ছে সেসব সংখা যাদেরকে ১ ও ওই সংখ্যা ছাড়া অন্য কোন ভাগ করা যায় না, অন্যভাবে, ১ ও ওই সংখ্যা ছাড়া কোনো বিভাজ্য নেই। এখন তোমাকে যদি একটি সংখ্যা N দেওয়া থাকে এবং বলা হয় ১ থেকে N  পর্যন্ত সকল মৌলিক সংখ্যা তোমাকে জেনারেট করতে হবে তাহলে তুমি কিভাবে করবে? অবশ্যই অনেকগুলো পদ্ধতি প্রচলিত রয়েছে, কিন্তু সবচাইতে ইফেকটিভ ও ইফিসিয়েন্ট পদ্ধতি হচ্ছে **Seive of Eratosthenes**. 

আলোচনার সুবিধার্থে আমরা N =১০০ ধরে নিতে পারি। আরেকটা ভেক্টর primes  নিয়ে নিলাম, যেখানে সকল প্রাইম সংখ্যাগুলোকে আমরা রিজার্ভ করবো। 

**Seive of Eratosthenes** কিভাবে কাজ করে সেটা আমরা এখন বিস্তারিত আলোচনা করব। আমরা জানি ১ অবশ্যই একটি মৌলিক সংখ্যা নয়, তাই তাকে আমরা বাদ দিয়ে আলোচনা করতে পারি। তাহলে সবচেয়ে ছোট মৌলিক সংখ্যাটি হচ্ছে ২। এবং আমরা এও বলতে পারি, এমন কোন সংখ্যা মৌলিক সংখ্যা হবে না যাদেরকে ২ দ্বারা ভাগ করা যায়। তাহলে আমাদের প্রথম কাজ হচ্ছে ২ কে প্রাইম হিসেবে কালেক্ট করা এবং এরপর দুই দ্বারা বিভাজ্য বাকি সকল সংখ্যাকে (৪,৬,৮,১০,...) মার্ক করে দেয়া যে তারা কেউই মৌলিক সংখ্যা নয়।

এবার আমরা ৩ এর জন্য অনুরূপ অপারেশন পারফর্ম করব। অর্থাৎ, ৩ কে আমরা প্রাইম হিসেবে কালেক্ট করব এবং ৩ দ্বারা বিভাজ্য সকল সংখ্যাকে (৬,৯,১২,১৫,...) আমরা চিহ্নিত করব যে তারা কেউ মৌলিক সংখ্যা নয়।

এবার আমাদের পরবর্তী টার্গেট হচ্ছে ৪, কিন্তু সে মৌলিক নয় হিসেবে মার্ক হয়ে গেছে। তাই আমাদের ৪ এর জন্য অপারেশন করতে হবে না।

সারকথা হচ্ছে আমরা ২ থেকে N পর্যন্ত সকল সংখ্যার জন্য প্রথমত চেক করব যে ঐ সংখ্যাটি নন-প্রাইম হিসেবে অলরেডি মার্ক হয়েছে কিনা। যদি না হয়ে থাকে, তাহলে তাকে আমরা প্রাইম হিসেবে কালেক্ট করব এবং তার সকল ডিভিসরকে আমরা নন-প্রাইম হিসেবে মার্ক করব।

<div align="center">
    <img src="https://github.com/Md-Johaer-Plabon/AlgoBangla/blob/main/Contents/seive_of_eratosthenes.png" height="300" width="600">
</div>
<br>

এতক্ষন ধরে আমরা যা কিছু বুঝতে পারলাম, তাকে যদি কোডে রিপ্লেস করি, তাহলে নিচের কোডটির মতো হবে:

```cpp
vector<int>primes;
bool color[N+5];

void seive() {
	for(int i=2; i<=N; i++) {
		if(color[i] == false) { // i is not already marked as non-prime
			primes.push_back(i); // Take i as prime
			for(int j=i+i; j<=N; j+=i) {
				color[j] = true; // Mark all divisors of i as non-prime
			}
		}
	}
}
```

এবার কোডটির optimization নিয়ে ভাবা যাক। আলোচনার সুবিধার্থে i=৫ ধরে নেয়া যাক। যেহেতু i একটি প্রাইম হয়, তাহলে আমরা i+i (2i) থেকে সব ডিভিসর 2i, 3i, 4i, ... কে মার্ক করে দিয়েছি যে তারা প্রাইম নয়। কিন্তু একটু খেয়াল করে দেখো, 2i=১০ অলরেডি মার্কড (২ এর সময় আমরা তাকে মার্ক করেছি), 3i=১৫ অলরেডি মার্কড (২ এর সময় আমরা তাকে মার্ক করেছি), 4i=২০ অলরেডি মার্কড (২ এর সময় আমরা তাকে মার্ক করেছি)। ৫i=২৫  মার্ক হয় নাই, তাই ৫i থেকে আমরা এখন মার্ক করলেই পারি। 

বস্তুত i*i এর আগে পর্যন্ত সব ডিভিসরগুলোকে তুমি সবসময় মার্কড পাবা, কেননা তারা সবসময় কোনো না কোনো ছোট প্রাইম দিয়ে ইতোমধ্যে মার্কড হয়ে যাবে। 
তাহলে অপটিমাইজড কোডটি হলো:

```cpp
void seive() {
	for(int i=2; i<=N; i++) {
		if(color[i] == false) {
			primes.push_back(i);
			for(int j=i*i; j<=N; j+=i) {
				color[j] = true;
			}
		}
	}
}
```


আরেকটা  ছোট optimization আছে, যখন i এর মান বড় এবং i*i ইন্টিজার ওভারফ্লো করে। এই অংশটুকু তোমাকে চিন্তা করার জন্য রেখে দিলাম। 



## কমপ্লেক্সিটি: 

আশা করি সিভ এর কারসাজি এতক্ষনে বুঝে গেছো। এবার তাহলে এর কমপ্লেক্সিটি নিয়ে আলোচনা করা যাক। আচ্ছা, প্রথম সিভের কোডটি লক্ষ্য করে বলতে পারবে N এর যেকোনো মানের জন্য প্রায় কতবার ইটারেশন এর প্রযোজন হয়? আমরা এখানে প্রতিবার চেক করছি সংখ্যাটি প্রাইম কিনা, অতঃপর যদি প্রাইম হয়, তাহলে তার N-পর্যন্ত সব গুণিতক কে আমরা নন-প্রাইম হিসেবে মার্ক করছি। তাহলে-

2 এর জন্য আমরা লুপ চালাচ্ছি 4, 6, 8, 10, ..., <= N পর্যন্ত  N/2 বার (প্রায়) </br>
3 এর জন্য আমরা লুপ চালাচ্ছি 6, 9, 12, 15, ..., <= N পর্যন্ত N/3 বার (প্রায়) </br>
5 এর জন্য আমরা লুপ চালাচ্ছি 10, 15, 20, 25, ..., <= N পর্যন্ত N/5 বার (প্রায়) </br>

তাহলে মতো কতগুলো ইটারেশন হতে পারে? উত্তর N/2 + N/3 + N/5 + N/7 + ..., যার মান প্রায় N log N । 

কিন্তু দ্বিতীয় কোডটিতে আমরা যেহেতু প্রতিটি প্রাইম এর জন্য তার বর্গ থেকে ইটারেশন শুরু করেছি, তাই তখন ইটারেশন কমে N/2² + N/3² + N/5² + N/7² + ... + (N /p²) = N log (log N ) তে পরিণত হয়। মজার না?

